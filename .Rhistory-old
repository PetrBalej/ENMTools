env.files <- list.files(path = "test/testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
ahli
ahli$species.name <- "ahli"
ahli$presence.points <- read.csv("test/testdata/ahli.csv")[,3:4]
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
ahli
allogus <- enmtools.species(species.name = "allogus",
presence.points = read.csv("test/testdata/allogus.csv")[,3:4])
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
allogus$background.points <- background.points.buffer(points = allogus$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
allogus
ahli.gam <- enmtools.gam(ahli, env, test.prop = 0.2)
ahli.gam
ahli.ppm <- enmtools.ppmlasso(ahli, env, test.prop = 0.2, back.accurate = TRUE, normalise = TRUE)
ahli.ppm
ahli.ppm$response.plots
ahli.gam$response.plots
allogus.ppm <- enmtools.ppmlasso(allogus, env[[1:2]], test.prop = 0.2, normalise = TRUE)
allogus.ppm
allogus.ppm$response.plots
allogus.ppm <- enmtools.ppmlasso(allogus, env, test.prop = 0.2, normalise = TRUE)
allogus.ppm
allogus.ppm$response.plots
visualize.enm(allogus.ppm, env, layers = names(env)[1:2])
help(predict)
allogus.rf <- enmtools.rf(allogus, env, test.prop = 0.2)
allogus.rf
class(allogus.rf$model)
predict.randomForest
methods(plot)
install.packages("~/GitHub/ENMTools_0.2.tar.gz", repos = NULL, type = "source")
setwd("~/GitHub/ENMTools Test Code and Junk/")
library(ENMTools)
env.files <- list.files(path = "test/testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
ahli
ahli$species.name <- "ahli"
ahli$presence.points <- read.csv("test/testdata/ahli.csv")[,3:4]
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
ahli
allogus <- enmtools.species(species.name = "allogus",
presence.points = read.csv("test/testdata/allogus.csv")[,3:4])
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
allogus$background.points <- background.points.buffer(points = allogus$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
allogus
ahli.gam <- enmtools.gam(ahli, env, test.prop = 0.2)
ahli.gam
fix(enmtools.gam)
allogus.ppm <- enmtools.ppmlasso(allogus, env, test.prop = 0.2, normalise = TRUE)
allogus.ppm
allogus.ppm$response.plots
allogus.rf <- enmtools.rf(allogus, env, test.prop = 0.2)
install.packages("~/GitHub/ENMTools_0.2.tar.gz", repos = NULL, type = "source")
setwd("~/GitHub/ENMTools Test Code and Junk/")
library(ENMTools)
env.files <- list.files(path = "test/testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
ahli
ahli$species.name <- "ahli"
ahli$presence.points <- read.csv("test/testdata/ahli.csv")[,3:4]
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
ahli
allogus <- enmtools.species(species.name = "allogus",
presence.points = read.csv("test/testdata/allogus.csv")[,3:4])
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
allogus$background.points <- background.points.buffer(points = allogus$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
allogus
allogus.rf <- enmtools.rf(allogus, env, test.prop = 0.2)
allogus.rf
allogus.rf$response.plots
allogus.bc <- enmtools.bc(allogus, env, test.prop = 0.2)
allogus.bc
help(predict)
species = allogus
test.prop = 0.2
nback = 1000
notes <- NULL
species <- check.bg(species, env, nback)
bc.precheck(species, env)
test.data <- NA
test.evaluation <- NA
env.test.evaluation <- NA
if(test.prop > 0 & test.prop < 1){
test.inds <- sample(1:nrow(species$presence.points), ceiling(nrow(species$presence.points) * test.prop))
test.data <- species$presence.points[test.inds,]
species$presence.points <- species$presence.points[-test.inds,]
}
# This is a very weird hack that has to be done because dismo's evaluate and bioclim function
# fail if the stack only has one layer.
if(length(names(env)) == 1){
oldname <- names(env)
env <- stack(env, env)
env[[2]][!is.na(env[[2]])] <- 0
names(env) <- c(oldname, "dummyvar")
notes <- c(notes, "Only one predictor was provided, so a dummy variable was created in order to be compatible with dismo's prediction function.")
}
this.bc <- bioclim(env, species$presence.points[,1:2])
suitability <- dismo::predict(env, this.bc, type = "response")
suitability
plot(suitability)
# This is a very weird hack that has to be done because dismo's evaluate function
# fails if the stack only has one layer.
if(length(names(env)) == 1){
oldname <- names(env)
env <- stack(env, env)
names(env) <- c(oldname, "dummyvar")
}
model.evaluation <-dismo::evaluate(species$presence.points[,1:2], species$background.points[,1:2],
this.bc, env)
env.model.evaluation <- env.evaluate(species, this.bc, env)
allogus.rf$test.data
allogus.rf$analysis.df
#' visualize.enm, Makes a heatmap of suitability of habitat in environment space according to a given model
#'
#' @param model An enmtools.model object
#' @param env A set of environmental layers
#' @param nbins The number of bins per layer to use for drawing environment space
#' @param layers A vector of layer names to use for drawing environment space
#' @param plot.points Logical determining whether presence points should be plotted on suitability plot
#'
#' @return suit.plot A two dimensional plot of an ENM
#'
#' @keywords niche plot sdm enm
#'
#' @export visualize.enm
#'
#' @examples
#' visualize.enm(1, .001, .001)
visualize.enm <- function(model, env, nbins = 100, layers = names(env), plot.points = TRUE){
if(!inherits(model, "enmtools.model")){
stop("This function requires an enmtools.model object!")
}
if(length(layers) != 2){
stop("Layers argument must be a character vector specifying two environmental layers to use for plotting!")
}
if(!all(layers %in% names(env))){
stop("Layer names provided do not match environmental rasters!")
}
# Grab points
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
points <- model$analysis.df
} else {
points <- model$analysis.df[model$analysis.df$presence == 1,1:2]
}
layer1.min <- min(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.min <- min(getValues(env[[layers[2]]]), na.rm=TRUE)
layer1.max <- max(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.max <- max(getValues(env[[layers[2]]]), na.rm=TRUE)
# Build plot df
plot.df <- cbind(rep(seq(layer1.min, layer1.max, length = nbins), nbins),
rep(seq(layer2.min, layer2.max, length = nbins), each = nbins))
# Create a vector of names in the right order for plot.df
names <- layers
for(i in names(env)){
if(!(i %in% layers)){
layer.values <- extract(env[[i]], points)
plot.df <- cbind(plot.df, rep(mean(layer.values, na.rm=TRUE), nrow(plot.df)))
names <- c(names, i)
}
}
pointdata <- as.data.frame(extract(env[[layers]], points))
colnames(plot.df) <- names
plot.df <- data.frame(plot.df)
pred <- predict(model$model, newdata = plot.df, type = "response")
plot.df <- cbind(plot.df[,1:2], pred)
suit.plot <- ggplot(data = plot.df, aes_string(y = names[2], x = names[1])) +
geom_raster(aes(fill = pred)) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability")) +
theme_classic() +
ggtitle(label = "Predicted suitability in environment space")
if(plot.points == TRUE){
suit.plot <- suit.plot  + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
# Do density plot of presence vs. background data
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
background.plot <- NA
} else {
bgpoints <- model$analysis.df[model$analysis.df$presence == 0,1:2]
bgdata <- as.data.frame(extract(env[[layers]], bgpoints))
background.plot <- ggplot(bgdata, aes_string(y = names[2], x = names[1])) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
xlim(layer1.min, layer1.max) + ylim(layer2.min, layer2.max) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Density")) + theme_classic() +
ggtitle(label = "Presence points and background density in environment space")
if(plot.points == TRUE){
background.plot <- background.plot + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
}
output <- list(background.plot = background.plot,
suit.plot = suit.plot)
return(output)
}
visualize.enm(allogus.rf, env[[1:2]])
names(env[[1:2]])
visualize.enm(allogus.rf, env[[1:3]])
#' visualize.enm, Makes a heatmap of suitability of habitat in environment space according to a given model
#'
#' @param model An enmtools.model object
#' @param env A set of environmental layers
#' @param nbins The number of bins per layer to use for drawing environment space
#' @param layers A vector of layer names to use for drawing environment space
#' @param plot.points Logical determining whether presence points should be plotted on suitability plot
#'
#' @return suit.plot A two dimensional plot of an ENM
#'
#' @keywords niche plot sdm enm
#'
#' @export visualize.enm
#'
#' @examples
#' visualize.enm(1, .001, .001)
visualize.enm <- function(model, env, nbins = 100, layers = names(env), plot.points = TRUE){
if(!inherits(model, "enmtools.model")){
stop("This function requires an enmtools.model object!")
}
if(length(layers) != 2){
stop("Layers argument must be a character vector specifying two environmental layers to use for plotting!")
}
if(!all(layers %in% names(env))){
stop("Layer names provided do not match environmental rasters!")
}
# Grab points
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
points <- model$analysis.df
} else {
points <- model$analysis.df[model$analysis.df$presence == 1,1:2]
}
layer1.min <- min(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.min <- min(getValues(env[[layers[2]]]), na.rm=TRUE)
layer1.max <- max(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.max <- max(getValues(env[[layers[2]]]), na.rm=TRUE)
# Build plot df
plot.df <- cbind(rep(seq(layer1.min, layer1.max, length = nbins), nbins),
rep(seq(layer2.min, layer2.max, length = nbins), each = nbins))
# Create a vector of names in the right order for plot.df
names <- layers
for(i in names(env)){
if(!(i %in% layers)){
layer.values <- extract(env[[i]], points)
plot.df <- cbind(plot.df, rep(mean(layer.values, na.rm=TRUE), nrow(plot.df)))
names <- c(names, i)
}
}
pointdata <- as.data.frame(extract(env[[layers]], points))
colnames(plot.df) <- names
plot.df <- data.frame(plot.df)
pred <- predict(model$model, newdata = plot.df, type = "response")
plot.df <- cbind(plot.df[,1:2], pred)
suit.plot <- ggplot(data = plot.df, aes_string(y = names[2], x = names[1])) +
geom_raster(aes(fill = pred)) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability")) +
theme_classic() +
ggtitle(label = "Predicted suitability in environment space")
if(plot.points == TRUE){
suit.plot <- suit.plot  + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
# Do density plot of presence vs. background data
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
background.plot <- NA
} else {
bgpoints <- model$analysis.df[model$analysis.df$presence == 0,1:2]
bgdata <- as.data.frame(extract(env[[layers]], bgpoints))
background.plot <- ggplot(bgdata, aes_string(y = names[2], x = names[1])) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
xlim(layer1.min, layer1.max) + ylim(layer2.min, layer2.max) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Density")) + theme_classic() +
ggtitle(label = "Presence points and background density in environment space")
if(plot.points == TRUE){
background.plot <- background.plot + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
}
output <- list(background.plot = background.plot,
suit.plot = suit.plot)
return(output)
}
setwd("~/GitHub/ENMTools Test Code and Junk/")
library(ENMTools)
env.files <- list.files(path = "test/testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
ahli
ahli$species.name <- "ahli"
ahli$presence.points <- read.csv("test/testdata/ahli.csv")[,3:4]
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
ahli
allogus <- enmtools.species(species.name = "allogus",
presence.points = read.csv("test/testdata/allogus.csv")[,3:4])
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
allogus$background.points <- background.points.buffer(points = allogus$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
allogus
allogus.gam <- enmtools.gam(allogus, env, test.prop = 0.2)
allogus.gam
visualize.enm(allogus.gam, env[[1:2]])
#' visualize.enm, Makes a heatmap of suitability of habitat in environment space according to a given model
#'
#' @param model An enmtools.model object
#' @param env A set of environmental layers
#' @param nbins The number of bins per layer to use for drawing environment space
#' @param layers A vector of layer names to use for drawing environment space
#' @param plot.points Logical determining whether presence points should be plotted on suitability plot
#'
#' @return suit.plot A two dimensional plot of an ENM
#'
#' @keywords niche plot sdm enm
#'
#' @export visualize.enm
#'
#' @examples
#' visualize.enm(1, .001, .001)
visualize.enm <- function(model, env, nbins = 100, layers = names(env), plot.points = TRUE){
if(!inherits(model, "enmtools.model")){
stop("This function requires an enmtools.model object!")
}
if(length(layers) != 2){
stop("Layers argument must be a character vector specifying two environmental layers to use for plotting!")
}
if(!all(layers %in% names(env))){
stop("Layer names provided do not match environmental rasters!")
}
# Grab points
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
points <- model$analysis.df
} else {
points <- model$analysis.df[model$analysis.df$presence == 1,1:2]
}
layer1.min <- min(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.min <- min(getValues(env[[layers[2]]]), na.rm=TRUE)
layer1.max <- max(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.max <- max(getValues(env[[layers[2]]]), na.rm=TRUE)
# Build plot df
plot.df <- cbind(rep(seq(layer1.min, layer1.max, length = nbins), nbins),
rep(seq(layer2.min, layer2.max, length = nbins), each = nbins))
# Create a vector of names in the right order for plot.df
names <- layers
for(i in names(env)){
if(!(i %in% layers)){
layer.values <- extract(env[[i]], points)
plot.df <- cbind(plot.df, rep(mean(layer.values, na.rm=TRUE), nrow(plot.df)))
names <- c(names, i)
}
}
pointdata <- as.data.frame(extract(env[[layers]], points))
colnames(plot.df) <- names
plot.df <- data.frame(plot.df)
pred <- predict(model$model, newdata = plot.df, type = "response")
plot.df <- cbind(plot.df[,1:2], pred)
suit.plot <- ggplot(data = plot.df, aes_string(y = names[2], x = names[1])) +
geom_raster(aes(fill = pred)) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability")) +
theme_classic() +
ggtitle(label = "Predicted suitability in environment space")
if(plot.points == TRUE){
suit.plot <- suit.plot  + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
# Do density plot of presence vs. background data
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
background.plot <- NA
} else {
bgpoints <- model$analysis.df[model$analysis.df$presence == 0,1:2]
bgdata <- as.data.frame(extract(env[[layers]], bgpoints))
background.plot <- ggplot(bgdata, aes_string(y = names[2], x = names[1])) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
xlim(layer1.min, layer1.max) + ylim(layer2.min, layer2.max) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Density")) + theme_classic() +
ggtitle(label = "Presence points and background density in environment space")
if(plot.points == TRUE){
background.plot <- background.plot + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
}
output <- list(background.plot = background.plot,
suit.plot = suit.plot)
return(output)
}
visualize.enm(allogus.gam, env[[1:2]])
visualize.enm(allogus.gam, env[[1:2]], layers = names(layers)[1:2])
visualize.enm(allogus.gam, env[[1:2]], layers = names(env)[1:2])
visualize.enm(allogus.gam, env, layers = names(env)[1:2])
#' visualize.enm, Makes a heatmap of suitability of habitat in environment space according to a given model
#'
#' @param model An enmtools.model object
#' @param env A set of environmental layers
#' @param nbins The number of bins per layer to use for drawing environment space
#' @param layers A vector of layer names to use for drawing environment space
#' @param plot.points Logical determining whether presence points should be plotted on suitability plot
#'
#' @return suit.plot A two dimensional plot of an ENM
#'
#' @keywords niche plot sdm enm
#'
#' @export visualize.enm
#'
#' @examples
#' visualize.enm(1, .001, .001)
visualize.enm <- function(model, env, nbins = 100, layers = names(env)[1:2], plot.points = TRUE){
if(!inherits(model, "enmtools.model")){
stop("This function requires an enmtools.model object!")
}
if(length(layers) != 2){
stop("Layers argument must be a character vector specifying two environmental layers to use for plotting!")
}
if(!all(layers %in% names(env))){
stop("Layer names provided do not match environmental rasters!")
}
# Grab points
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
points <- model$analysis.df
} else {
points <- model$analysis.df[model$analysis.df$presence == 1,1:2]
}
layer1.min <- min(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.min <- min(getValues(env[[layers[2]]]), na.rm=TRUE)
layer1.max <- max(getValues(env[[layers[1]]]), na.rm=TRUE)
layer2.max <- max(getValues(env[[layers[2]]]), na.rm=TRUE)
# Build plot df
plot.df <- cbind(rep(seq(layer1.min, layer1.max, length = nbins), nbins),
rep(seq(layer2.min, layer2.max, length = nbins), each = nbins))
# Create a vector of names in the right order for plot.df
names <- layers
for(i in names(env)){
if(!(i %in% layers)){
layer.values <- extract(env[[i]], points)
plot.df <- cbind(plot.df, rep(mean(layer.values, na.rm=TRUE), nrow(plot.df)))
names <- c(names, i)
}
}
pointdata <- as.data.frame(extract(env[[layers]], points))
colnames(plot.df) <- names
plot.df <- data.frame(plot.df)
pred <- predict(model$model, newdata = plot.df, type = "response")
plot.df <- cbind(plot.df[,1:2], pred)
suit.plot <- ggplot(data = plot.df, aes_string(y = names[2], x = names[1])) +
geom_raster(aes(fill = pred)) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Suitability")) +
theme_classic() +
ggtitle(label = "Predicted suitability in environment space")
if(plot.points == TRUE){
suit.plot <- suit.plot  + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
# Do density plot of presence vs. background data
if(inherits(model, c("enmtools.bc", "enmtools.dm"))){
background.plot <- NA
} else {
bgpoints <- model$analysis.df[model$analysis.df$presence == 0,1:2]
bgdata <- as.data.frame(extract(env[[layers]], bgpoints))
background.plot <- ggplot(bgdata, aes_string(y = names[2], x = names[1])) +
stat_density_2d(aes(fill = ..density..), geom = "raster", contour = FALSE) +
xlim(layer1.min, layer1.max) + ylim(layer2.min, layer2.max) +
scale_fill_viridis(option = "B", guide = guide_colourbar(title = "Density")) + theme_classic() +
ggtitle(label = "Presence points and background density in environment space")
if(plot.points == TRUE){
background.plot <- background.plot + geom_point(data = pointdata, aes_string(y = names[2], x = names[1]),
pch = 21, fill = "white", color = "black", size = 3)
}
}
output <- list(background.plot = background.plot,
suit.plot = suit.plot)
return(output)
}
visualize.enm(allogus.gam, env)
setwd("~/GitHub/ENMTools Test Code and Junk/")
library(ENMTools)
env.files <- list.files(path = "test/testdata/", pattern = "pc", full.names = TRUE)
env <- stack(env.files)
names(env) <- c("layer.1", "layer.2", "layer.3", "layer.4")
env <- setMinMax(env)
ahli <- enmtools.species()
ahli
ahli$species.name <- "ahli"
ahli$presence.points <- read.csv("test/testdata/ahli.csv")[,3:4]
ahli$range <- background.raster.buffer(ahli$presence.points, 50000, mask = env)
ahli$background.points <- background.points.buffer(points = ahli$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
ahli
allogus <- enmtools.species(species.name = "allogus",
presence.points = read.csv("test/testdata/allogus.csv")[,3:4])
allogus$range <- background.raster.buffer(allogus$presence.points, 50000, mask = env)
allogus$background.points <- background.points.buffer(points = allogus$presence.points,
radius = 20000, n = 1000, mask = env[[1]])
allogus
allogus.dm <- enmtools.dm(allogus, env, test.prop = 0.2)
allogus.dm
